%YAML 1.2
---
# See http://www.sublimetext.com/docs/syntax.html
name: Sophia
file_extensions:
  - aes
scope: source.sophia

variables:
  RE_ID: "[a-z_][0-9a-zA-Z_']*"
  RE_CON: "[A-Z][A-Za-z0-9_']*"
  RE_KEYWORDS:
    \b(contract|include|let|switch|type|record|datatype|if|elif|else|function|stateful|payable|public|entrypoint|private|indexed|namespace|interface|main|using|as|for|hiding)\b
  RE_CONSTANTS: \b(true|false)\b
  RE_PRIMITIVES: \b(int|address|bool|bits|bytes|string|list|option|char|unit|map|event|hash|signature|oracle|oracle_query)\b
  RE_BUILDIN_FUNCTIONS: \b(state|put|abort|require)\b

contexts:
  commentLine:
    - match: //.*
      scope: comment.line

  commentBlock:
    - match: /\*
      push:
        - meta_scope: comment.block
        - match: \*/
          pop: true

  punctuations:
    - match: '~'
      scope: punctuation.definition.keyword
    - match: ;
      scope: punctuation.terminator
    - match: \.
      scope: punctuation.accessor
    - match: \,
      scope: punctuation.separator
    - match: \|(?!\|)
      scope: punctuation.separator
    - match: \[
      scope: punctuation.section.brackets.begin
      push: brackets
    - match: \]
      scope: invalid.illegal.stray-bracket-end
    - match: \{
      scope: punctuation.section.braces.begin
      push: braces
    - match: \}
      scope: invalid.illegal.stray-bracket-end
    - match: \(
      scope: punctuation.section.parens.begin
      push: parens
    - match: \)
      scope: invalid.illegal.stray-bracket-end

  brackets:
    - match: \]
      scope: punctuation.section.brackets.end
      pop: true
    - include: main

  braces:
    - match: \}
      scope: punctuation.section.braces.end
      pop: true
    - include: main

  parens:
    - match: \)
      scope: punctuation.section.parens.end
      pop: true
    - include: main

  storage:
    - match: '{{RE_PRIMITIVES}}'
      scope: storage.type.aes

  keyword:
    - match: '{{RE_KEYWORDS}}'
      scope: keyword.aes

  constant:
    - match: '{{RE_CONSTANTS}}'
      scope: constant.language.aes

  address_constant:
    - match: '(ak_|ok_|oq_|ct_)[\w]+'
      scope: constant.numeric.address.aes

  buildin_functions:
    - match: '{{RE_BUILDIN_FUNCTIONS}}'
      scope: support.function.aes

  buildin_types:
    # not semantically correct but should do the job
    - match: '\bindexed\b'
      scope: support.type.aes

  string:
    - match: '"'
      scope: punctuation.definition.string.begin
      push:
      - meta_scope: string.quoted.double
      - match: '"'
        scope: punctuation.definition.string.end
        pop: true
      - include: escape_sequence

  escape_sequence:
      - match: \\x[0-9a-fA-F]{2}
        scope: constant.character.escape
      - match: \\[0-9]{3}
        scope: constant.character.escape
      - match: \\.
        scope: constant.character.escape

  character:
    - match: '''.'''
      scope: string.quoted.single
    - include: escape_sequence

  bytes:
    - match:
        '#[0-9a-fA-F][0-9a-fA-F_]*'
      scope: constant.numeric.integer.other

  integer:
    - match:
        \b(\d[\d_]*)\b
      scope: constant.numeric.integer

  hexadecimal:
    - match:
        \b(0[xX][\da-fA-F][\da-fA-F_]*)\b
      scope: constant.numeric.hexadecimal

  modifiers:
    - match: \b(payable|stateful|private)\b
      scope: storage.modifier

  pragma:
    - match: '(@\w+)\s(=<|>=|==|!=|<|>)\s([\d\.]+)'
      scope: meta.preprocessor 
      captures:
        1: punctuation.definition.annotation
        2: keyword.operator.other
        3: variable.other.constant

  operator:
    - match:
        '::|\+\+'
      # list operators
      scope: keyword.operator.other
    - match:
        '<<|>>'
      scope: keyword.operator.bitwise
    - match:
        '=<|>=|==|!=|<|>'
      # no comparison scope :(
      scope: keyword.operator.other
    - match:
        '\|\||&&|!'
      scope: keyword.operator.logical
    - match: 
        '\b(mod|band|bor|bxor|bnot)\b'
      scope: keyword.operator.word
    - match:
        '\+|-|\*|/|\^'
      scope: keyword.operator.arithmetic
    - match: '='
      scope: keyword.operator.assignment

  namespace:
    - match: 
        '(namespace)\s+({{RE_CON}})\s+(=)'
      captures:
        1: keyword.other
        2: entity.name.namespace
        3: keyword.operator.assignment

  typedefs:
    - match:
        '\b(type|record|datatype)\s+({{RE_ID}})\b'
      captures:
        # first one is apparently for backward-compat
        1: storage.type keyword.declaration.type
        2: entity.name.type

  function:
    - match:
        '\b(function|entrypoint)\s({{RE_ID}})\b'
      captures:
        # first one is apparently for backward-compat
        1: storage.type.function keyword.declaration.function
        2: entity.name.function

  contract:
    - match:
        '\b(main\s)?(contract)\s({{RE_CON}})\b'
      captures:
        1: storage.modifier
        # first one is apparently for backward-compat
        2: storage.type.class keyword.declaration.class
        3: entity.name.class

  interface:
    - match:
        '\b(contract\sinterface)\s({{RE_CON}})\b'
      captures:
        # first one is apparently for backward-compat
        1: storage.type.interface keyword.declaration.interface
        2: entity.name.interface

  constructor:
    - match: '\b[A-Z][0-9a-zA-Z_]*\b'
      scope: variable.function variable.other

  function-call:
    - meta_scope: meta.function-call
    - match:
        '\b{{RE_ID}}\b(?=\()'
      scope: variable.function
      push: function-call-arguments

    # - match: (?=\()
    #   scope: punctuation.section.parens.begin.aes

  function-call-arguments:
    - match: \(
      scope: punctuation.section.parameters.begin.aes
      set:
        - meta_scope: meta.function-call.parameters.aes
        - match: \)
          scope: punctuation.section.parameters.end.aes
          pop: true
        - match: ','
          scope: punctuation.separator.parameters.aes
        - include: main

  includeModule:
    - match: '\binclude\s(?=\S)'
      scope: keyword.control.import

  qualifiedIdentifiers:
    - match: '\b({{RE_CON}})(\.)({{RE_ID}})'
      captures:
        1: support.class
        2: punctuation.accessor
        3: variable.other.member

  qualifiedConstructor:
    - match: '\b({{RE_CON}})(\.)({{RE_CON}})'
      captures:
        1: support.class
        2: punctuation.accessor
        3: variable.function

  main:
    - include: pragma
    - include: namespace
    - include: typedefs
    - include: storage
    - include: constant
    - include: address_constant
    - include: commentLine
    - include: commentBlock
    - include: character
    - include: string
    - include: modifiers
    - include: buildin_types
    - include: buildin_functions
    - include: function
    - include: interface
    - include: contract
    - include: list
    - include: qualifiedIdentifiers
    - include: qualifiedConstructor
    - include: operator
    - include: integer
    - include: hexadecimal
    - include: bytes
    - include: includeModule
    - include: constructor
    # - include: function-call
    - include: keyword
    - include: punctuations
